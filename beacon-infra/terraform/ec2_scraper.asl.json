{
  "Comment": "Express Step Function to scrape AWS EC2 instances using Resource Explorer with JSONata transformations and DynamoDB caching",
  "StartAt": "InitializeEC2ScraperContext",
  "QueryLanguage": "JSONata",
  "StateMachineType": "EXPRESS",
  "States": {
    "InitializeEC2ScraperContext": {
      "Type": "Pass",
      "Comment": "Initialize EC2 scraper context and validate input parameters",
      "QueryLanguage": "JSONata",
      "Assign": {
        "scraperId": "{% $uuid() %}",
        "serviceType": "ec2-instances",
        "timestamp": "{% $now() %}",
        "accountId": "{% $states.input.accountId %}",
        "resourceExplorerViewArn": "{% $states.input.resourceExplorerViewArn %}"
      },
      "Output": "{% {'scraperId': $scraperId, 'serviceType': $serviceType, 'timestamp': $timestamp, 'accountId': $accountId, 'resourceExplorerViewArn': $resourceExplorerViewArn} %}",
      "Next": "CheckCacheForRecentScrape"
    },
    "CheckCacheForRecentScrape": {
      "Type": "Task",
      "Comment": "Check DynamoDB cache for recent EC2 scrape data",
      "Resource": "arn:aws:states:::aws-sdk:dynamodb:getItem",
      "QueryLanguage": "JSONata",
      "Arguments": {
        "TableName": "{% $states.input.cacheTableName ? $states.input.cacheTableName : 'aws-scraper-cache' %}",
        "Key": {
          "pk": {"S": "{% 'SCRAPE_CACHE#' & $accountId %}"},
          "sk": {"S": "{% $serviceType & '#LATEST' %}"}
        },
        "ConsistentRead": true
      },
      "Output": "{% $merge([$states.input, {'cacheResult': $states.result}]) %}",
      "Catch": [
        {
          "ErrorEquals": ["States.ALL"],
          "Output": "{% $merge([$states.input, {'cacheError': $states.errorOutput, 'proceedWithScrape': true}]) %}",
          "Next": "DiscoverEC2ResourcesWithExplorer"
        }
      ],
      "Next": "EvaluateCacheAge"
    },
    "EvaluateCacheAge": {
      "Type": "Choice",
      "Comment": "Determine if cached data is recent enough (30 minutes) to skip scraping",
      "QueryLanguage": "JSONata",
      "Choices": [
        {
          "Condition": "{% $exists($states.input.cacheResult.Item) and ($millis() - $number($states.input.cacheResult.Item.lastScraped.S)) < 1800000 %}",
          "Output": "{% {'useCache': true, 'cachedData': $states.input.cacheResult.Item} %}",
          "Next": "ReturnCachedResults"
        }
      ],
      "Default": "DiscoverEC2ResourcesWithExplorer"
    },
    "ReturnCachedResults": {
      "Type": "Pass",
      "Comment": "Return cached EC2 data without performing fresh scrape",
      "QueryLanguage": "JSONata",
      "Output": "{% {'source': 'cache', 'data': $parse($states.input.cachedData.ec2Data.S), 'timestamp': $states.input.cachedData.lastScraped.S, 'scraperId': $states.input.scraperId} %}",
      "End": true
    },
    "DiscoverEC2ResourcesWithExplorer": {
      "Type": "Task",
      "Comment": "Use Resource Explorer to discover all EC2 instances across regions efficiently",
      "Resource": "arn:aws:states:::aws-sdk:resourceExplorer2:search",
      "QueryLanguage": "JSONata",
      "Arguments": {
        "QueryString": "resourcetype:ec2:instance",
        "ViewArn": "{% $states.input.resourceExplorerViewArn %}",
        "MaxResults": 1000
      },
      "Output": "{% $merge([$states.input, {'discoveredResources': $states.result.Resources, 'nextToken': $states.result.NextToken}]) %}",
      "Catch": [
        {
          "ErrorEquals": ["States.ALL"],
          "Output": "{% $merge([$states.input, {'explorerError': $states.errorOutput, 'discoveredResources': []}]) %}",
          "Next": "HandleExplorerError"
        }
      ],
      "Next": "CheckForMoreResources"
    },
    "CheckForMoreResources": {
      "Type": "Choice",
      "Comment": "Check if there are more resources to retrieve with pagination",
      "QueryLanguage": "JSONata",
      "Choices": [
        {
          "Condition": "{% $exists($states.input.nextToken) %}",
          "Next": "FetchMoreEC2Resources"
        }
      ],
      "Default": "EnrichEC2ResourcesWithDetails"
    },
    "FetchMoreEC2Resources": {
      "Type": "Task",
      "Comment": "Continue fetching EC2 resources using pagination token",
      "Resource": "arn:aws:states:::aws-sdk:resourceExplorer2:search",
      "QueryLanguage": "JSONata",
      "Arguments": {
        "QueryString": "resourcetype:ec2:instance",
        "ViewArn": "{% $states.input.resourceExplorerViewArn %}",
        "MaxResults": 1000,
        "NextToken": "{% $states.input.nextToken %}"
      },
      "Output": "{% $merge([$states.input, {'discoveredResources': $append($states.input.discoveredResources, $states.result.Resources), 'nextToken': $states.result.NextToken}]) %}",
      "Next": "CheckForMoreResources"
    },
    "EnrichEC2ResourcesWithDetails": {
      "Type": "Map",
      "Comment": "Enrich each discovered EC2 resource with detailed information",
      "QueryLanguage": "JSONata",
      "Items": "{% $states.input.discoveredResources %}",
      "MaxConcurrency": 15,
      "ItemSelector": {
        "resourceArn": "{% $states.context.Map.Item.Value.Arn %}",
        "region": "{% $states.context.Map.Item.Value.Region %}",
        "instanceId": "{% $split($states.context.Map.Item.Value.Arn, '/')[1] %}",
        "basicInfo": "{% $states.context.Map.Item.Value %}"
      },
      "ItemProcessor": {
        "StartAt": "GetEC2InstanceDetails",
        "States": {
          "GetEC2InstanceDetails": {
            "Type": "Task",
            "Comment": "Fetch detailed EC2 instance information",
            "Resource": "arn:aws:states:::aws-sdk:ec2:describeInstances",
            "QueryLanguage": "JSONata",
            "Arguments": {
              "InstanceIds": ["{% $states.input.instanceId %}"]
            },
            "Output": "{% {'instanceId': $states.input.instanceId, 'region': $states.input.region, 'resourceArn': $states.input.resourceArn, 'basicInfo': $states.input.basicInfo, 'detailedInfo': $states.result.Reservations[0].Instances[0], 'tags': $reduce($states.result.Reservations[0].Instances[0].Tags, function($acc, $tag) { $merge([$acc, {$tag.Key: $tag.Value}]) }, {}), 'lastScraped': $now(), 'enrichmentSuccess': true} %}",
            "Catch": [
              {
                "ErrorEquals": ["States.ALL"],
                "Output": "{% {'instanceId': $states.input.instanceId, 'region': $states.input.region, 'resourceArn': $states.input.resourceArn, 'basicInfo': $states.input.basicInfo, 'detailedInfo': null, 'tags': {}, 'error': $states.errorOutput, 'lastScraped': $now(), 'enrichmentSuccess': false} %}",
                "Next": "ReturnEC2ErrorResult"
              }
            ],
            "End": true
          },
          "ReturnEC2ErrorResult": {
            "Type": "Pass",
            "QueryLanguage": "JSONata",
            "Output": "{% $states.input %}",
            "End": true
          }
        }
      },
      "Output": "{% $merge([$states.input, {'enrichedInstances': $states.result}]) %}",
      "Next": "AggregateEC2Results"
    },
    "HandleExplorerError": {
      "Type": "Pass",
      "Comment": "Handle Resource Explorer errors gracefully",
      "QueryLanguage": "JSONata",
      "Output": "{% $merge([$states.input, {'enrichedInstances': [], 'explorerFailed': true}]) %}",
      "Next": "AggregateEC2Results"
    },
    "AggregateEC2Results": {
      "Type": "Pass",
      "Comment": "Aggregate and transform EC2 data into unified structure with associations",
      "QueryLanguage": "JSONata",
      "Assign": {
        "totalInstances": "{% $count($states.input.enrichedInstances) %}",
        "successfulEnrichments": "{% $count($states.input.enrichedInstances[enrichmentSuccess = true]) %}",
        "failedEnrichments": "{% $count($states.input.enrichedInstances[enrichmentSuccess = false]) %}",
        "regionBreakdown": "{% $reduce($states.input.enrichedInstances, function($acc, $instance) { $merge([$acc, {$instance.region: ($acc[$instance.region] ? $acc[$instance.region] + 1 : 1)}]) }, {}) %}",
        "instanceTypeBreakdown": "{% $reduce($states.input.enrichedInstances[enrichmentSuccess = true], function($acc, $instance) { $merge([$acc, {$instance.detailedInfo.InstanceType: ($acc[$instance.detailedInfo.InstanceType] ? $acc[$instance.detailedInfo.InstanceType] + 1 : 1)}]) }, {}) %}",
        "stateBreakdown": "{% $reduce($states.input.enrichedInstances[enrichmentSuccess = true], function($acc, $instance) { $merge([$acc, {$instance.detailedInfo.State.Name: ($acc[$instance.detailedInfo.State.Name] ? $acc[$instance.detailedInfo.State.Name] + 1 : 1)}]) }, {}) %}",
        "taggedInstances": "{% $count($states.input.enrichedInstances[$count($keys(tags)) > 0]) %}",
        "associations": "{% $map($states.input.enrichedInstances, function($instance) { {'instanceId': $instance.instanceId, 'accountOwnership': {'accountId': $accountId, 'relationship': 'owns'}, 'regionalPlacement': {'region': $instance.region, 'relationship': 'deployed_in'}, 'vpcAssociation': $instance.detailedInfo.VpcId ? {'vpcId': $instance.detailedInfo.VpcId, 'relationship': 'deployed_in_vpc'} : null, 'subnetAssociation': $instance.detailedInfo.SubnetId ? {'subnetId': $instance.detailedInfo.SubnetId, 'relationship': 'deployed_in_subnet'} : null, 'securityGroups': $map($instance.detailedInfo.SecurityGroups, function($sg) { {'groupId': $sg.GroupId, 'relationship': 'protected_by'} }), 'tagging': $map($keys($instance.tags), function($key) { {'key': $key, 'value': $instance.tags[$key], 'relationship': 'tagged_with'} })} }) %}"
      },
      "Output": "{% {'scraperId': $states.input.scraperId, 'serviceType': $states.input.serviceType, 'accountId': $states.input.accountId, 'timestamp': $states.input.timestamp, 'summary': {'totalInstances': $totalInstances, 'successfulEnrichments': $successfulEnrichments, 'failedEnrichments': $failedEnrichments, 'regionBreakdown': $regionBreakdown, 'instanceTypeBreakdown': $instanceTypeBreakdown, 'stateBreakdown': $stateBreakdown, 'taggedInstances': $taggedInstances}, 'data': {'ec2Instances': $states.input.enrichedInstances, 'associations': $associations}, 'explorerUsed': true} %}",
      "Next": "StoreResultsInDynamoDB"
    },
    "StoreResultsInDynamoDB": {
      "Type": "Task",
      "Comment": "Store scraped EC2 data in DynamoDB cache table with TTL",
      "Resource": "arn:aws:states:::aws-sdk:dynamodb:putItem",
      "QueryLanguage": "JSONata",
      "Arguments": {
        "TableName": "{% $states.input.cacheTableName ? $states.input.cacheTableName : 'aws-scraper-cache' %}",
        "Item": {
          "pk": {"S": "{% 'SCRAPE_CACHE#' & $states.input.accountId %}"},
          "sk": {"S": "{% $states.input.serviceType & '#LATEST' %}"},
          "scraperId": {"S": "{% $states.input.scraperId %}"},
          "serviceType": {"S": "{% $states.input.serviceType %}"},
          "accountId": {"S": "{% $states.input.accountId %}"},
          "lastScraped": {"S": "{% $millis() ~> $string %}"},
          "ec2Data": {"S": "{% $string($states.input.data) %}"},
          "summary": {"S": "{% $string($states.input.summary) %}"},
          "ttl": {"N": "{% ($millis() + 86400000) ~> $string %}"}
        }
      },
      "Output": "{% $merge([$states.input, {'cacheStored': true, 'cacheKey': 'SCRAPE_CACHE#' & $states.input.accountId & '#' & $states.input.serviceType}]) %}",
      "Catch": [
        {
          "ErrorEquals": ["States.ALL"],
          "Output": "{% $merge([$states.input, {'cacheError': $states.errorOutput, 'cacheStored': false}]) %}",
          "Next": "PrepareNeptuneUpdate"
        }
      ],
      "Next": "PrepareNeptuneUpdate"
    },
    "PrepareNeptuneUpdate": {
      "Type": "Pass",
      "Comment": "Transform EC2 data for Neptune graph database with comprehensive relationships",
      "QueryLanguage": "JSONata",
      "Assign": {
        "neptuneVertices": "{% $append($map($states.input.data.ec2Instances, function($instance) { {'id': $instance.instanceId, 'label': 'EC2Instance', 'properties': {'instanceType': $instance.detailedInfo.InstanceType, 'state': $instance.detailedInfo.State.Name, 'region': $instance.region, 'launchTime': $instance.detailedInfo.LaunchTime, 'publicIp': $instance.detailedInfo.PublicIpAddress, 'privateIp': $instance.detailedInfo.PrivateIpAddress, 'vpcId': $instance.detailedInfo.VpcId, 'subnetId': $instance.detailedInfo.SubnetId, 'arn': $instance.resourceArn, 'lastScraped': $instance.lastScraped}} }), [{'id': $states.input.accountId, 'label': 'AWSAccount', 'properties': {'accountId': $states.input.accountId, 'lastScanned': $now()}}]) %}",
        "neptuneEdges": "{% $reduce($states.input.data.ec2Instances, function($acc, $instance) { $append($acc, [{'from': $states.input.accountId, 'to': $instance.instanceId, 'label': 'OWNS', 'properties': {'relationship': 'ownership', 'discoveredAt': $instance.lastScraped}}, {'from': $instance.instanceId, 'to': $instance.region, 'label': 'DEPLOYED_IN', 'properties': {'relationship': 'regional_deployment', 'discoveredAt': $instance.lastScraped}}]) }, []) %}",
        "vpcEdges": "{% $reduce($states.input.data.ec2Instances[detailedInfo.VpcId], function($acc, $instance) { $append($acc, [{'from': $instance.instanceId, 'to': $instance.detailedInfo.VpcId, 'label': 'DEPLOYED_IN_VPC', 'properties': {'vpcId': $instance.detailedInfo.VpcId, 'discoveredAt': $instance.lastScraped}}]) }, []) %}",
        "tagEdges": "{% $reduce($states.input.data.ec2Instances, function($acc, $instance) { $append($acc, $map($keys($instance.tags), function($tagKey) { {'from': $instance.instanceId, 'to': $tagKey & ':' & $instance.tags[$tagKey], 'label': 'TAGGED_WITH', 'properties': {'tagKey': $tagKey, 'tagValue': $instance.tags[$tagKey], 'discoveredAt': $instance.lastScraped}} })) }, []) %}"
      },
      "Output": "{% $merge([$states.input, {'neptuneUpdate': {'vertices': $neptuneVertices, 'edges': $append($append($neptuneEdges, $vpcEdges), $tagEdges), 'updateType': 'ec2_scrape', 'timestamp': $now(), 'associations': $states.input.data.associations}}]) %}",
      "Next": "UpdateNeptuneGraph"
    },
    "UpdateNeptuneGraph": {
      "Type": "Task",
      "Comment": "Send transformed data to Neptune for graph updates via SQS queue",
      "Resource": "arn:aws:states:::sqs:sendMessage",
      "QueryLanguage": "JSONata",
      "Arguments": {
        "QueueUrl": "{% $states.input.neptuneUpdateQueueUrl %}",
        "MessageBody": "{% $string($states.input.neptuneUpdate) %}",
        "MessageAttributes": {
          "ServiceType": {
            "StringValue": "{% $states.input.serviceType %}",
            "DataType": "String"
          },
          "ScraperId": {
            "StringValue": "{% $states.input.scraperId %}",
            "DataType": "String"
          },
          "AccountId": {
            "StringValue": "{% $states.input.accountId %}",
            "DataType": "String"
          },
          "UpdateType": {
            "StringValue": "resource_discovery",
            "DataType": "String"
          }
        }
      },
      "Output": "{% $merge([$states.input, {'neptuneQueued': true, 'messageId': $states.result.MessageId}]) %}",
      "Catch": [
        {
          "ErrorEquals": ["States.ALL"],
          "Output": "{% $merge([$states.input, {'neptuneError': $states.errorOutput, 'neptuneQueued': false}]) %}",
          "Next": "FinalizeEC2ScraperResults"
        }
      ],
      "Next": "FinalizeEC2ScraperResults"
    },
    "FinalizeEC2ScraperResults": {
      "Type": "Pass",
      "Comment": "Finalize and format the complete scraper results with comprehensive metrics",
      "QueryLanguage": "JSONata",
      "Output": "{% {'scraperId': $states.input.scraperId, 'serviceType': $states.input.serviceType, 'accountId': $states.input.accountId, 'completedAt': $now(), 'source': 'fresh_scrape', 'summary': $states.input.summary, 'cacheStored': $states.input.cacheStored, 'neptuneQueued': $states.input.neptuneQueued, 'explorerUsed': true, 'data': $states.input.data, 'metrics': {'totalInstances': $states.input.summary.totalInstances, 'executionTime': ($millis() - $number($states.input.timestamp)) & 'ms', 'regionsCovered': $count($keys($states.input.summary.regionBreakdown)), 'associationsCreated': $count($states.input.data.associations)}} %}",
      "End": true
    }
  }
}