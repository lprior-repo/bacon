{
  "PrepareNeptuneUpdate": {
    "Type": "Pass",
    "Comment": "Transform data for Neptune graph database with comprehensive relationships",
    "QueryLanguage": "JSONata",
    "Assign": {
      "neptuneVertices": "{% ${VERTEX_TRANSFORMATION} %}",
      "neptuneEdges": "{% ${EDGE_TRANSFORMATION} %}"
    },
    "Output": "{% $merge([$states.input, {'neptuneUpdate': {'vertices': $neptuneVertices, 'edges': $neptuneEdges, 'updateType': '${UPDATE_TYPE}', 'timestamp': $now(), 'associations': $states.input.data.associations}}]) %}",
    "Next": "UpdateNeptuneGraph"
  },
  "UpdateNeptuneGraph": {
    "Type": "Task",
    "Comment": "Send transformed data to Neptune for graph updates via SQS queue",
    "Resource": "arn:aws:states:::sqs:sendMessage",
    "QueryLanguage": "JSONata",
    "Arguments": {
      "QueueUrl": "{% $states.input.neptuneUpdateQueueUrl %}",
      "MessageBody": "{% $string($states.input.neptuneUpdate) %}",
      "MessageAttributes": {
        "ServiceType": {
          "StringValue": "{% $states.input.serviceType %}",
          "DataType": "String"
        },
        "ScraperId": {
          "StringValue": "{% $states.input.scraperId %}",
          "DataType": "String"
        },
        "AccountId": {
          "StringValue": "{% $states.input.accountId %}",
          "DataType": "String"
        },
        "UpdateType": {
          "StringValue": "${UPDATE_TYPE}",
          "DataType": "String"
        }
      }
    },
    "Output": "{% $merge([$states.input, {'neptuneQueued': true, 'messageId': $states.result.MessageId}]) %}",
    "Catch": [
      {
        "ErrorEquals": ["States.ALL"],
        "Output": "{% $merge([$states.input, {'neptuneError': $states.errorOutput, 'neptuneQueued': false}]) %}",
        "Next": "${NEXT_STATE}"
      }
    ],
    "Next": "${NEXT_STATE}"
  }
}